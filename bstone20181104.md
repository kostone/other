## 【C/C++】定数について

C/C++で定数を作りたい！と思ったとき、すぐに思い浮かぶ方法は次の3つのはず

- `#define`
- `const`
- `enum`

それぞれどのように使い分けるべきなのか？をさまざまな観点で考えてみます


### #define

#### まずは簡単な使用例

```
#define EFFORT_VALUE_MAX 252

main(){
  int var = EFFORT_VALUE_MAX;
  printf("%d\n",var);
}
```

これはコンパイル時点で下記のようになる
```
main(){
  int var = 252;
}
```

#### 特徴
- コンパイル前にプリプロセッサで展開される
  - コンパイル時にシンボルが生成されない（＝デバッグでものすごく不便）
  - メモリ上に配置されない
    - メモリ容量を圧迫しない
    - アドレスが存在しない（ポインタ演算不可）
  - C/C++の文法的に間違っててもお構いなし
  - スコープ？何それ美味しいの？
  - 意図しない演算順序になってしまう恐れあり

### const
※ポインタに`const`を付ける場合等他の使い方については割愛します  
参考：http://starpentagon.net/life/2017/01/const/

#### 簡単な使用例

```
main(){
  const int var = 252;
  var = 510; // この行でエラーになる
  printf("%d\n",var);
}
```

#### 特徴
- C89で登場した「この変数は書き換え不可能」であることを示す修飾子
- この修飾子付きの変数に再代入しようとするとコンパイルエラーになる
- コンパイル時にシンボルが生成される（＝デバッグで定数名が使える）
- メモリ上に配置される
  - メモリ容量を食う
  - アドレスが存在する（ポインタ演算可能）
  - **読み取り専用のメモリ領域に配置されるわけではない**
    - つまり変数の値を書き換えようと思えば方法はある
    - このことから厳密に言えば定数ではなく「自分のことを定数だと思い込んでる変数」
- C/C++の文法チェックや型チェックをしてくれる
- 配列定義時に要素数として使用できなかった（C99で使用できるように）

### enum
※ C++11で新しく`enum class`が登場していますがここでは従来の`enum`についてです

#### 簡単な使用例

```
main(){
  enum evalue{
    eEFFORT_VALUE_MIN = 0;
    eEFFORT_VALUE_MAX = 255;
  };
  
  int var = eEFFORT_VALUE_MAX;
  printf("%d\n",var);
}
```

#### 特徴
- C89で登場した列挙型
- プリプロセッサでは置き換えられないが、コンパイラで置き換えられる
  - つまり`#define`と`const`の中間的立ち位置
  - コンパイル時にシンボルが生成される（＝デバッグで定数名が使える）
  - メモリ上に配置されない
    - メモリ容量を圧迫しない
    - アドレスが存在しない（ポインタ演算不可）
- C/C++の文法チェックや型チェックをしてくれる
- 配列定義時に要素数として使用できる
- **列挙定数の値は整数（基本的にint）で定義されるので、範囲外の値は使えない**

### #define VS const VS enum

||#define|const|enum|
|:---:|:---:|:---:|:---:|
|文法・型チェック|×|○|○|
|スコープ|×|○|○|
|メモリの使用量|○|△|○|
|ポインタ演算|×|○|×|
|デバッグのしやすさ|×|○|○|
|演算順序の予期せぬ変化|×|○|○|
|使用可能な値の範囲|○|○|△|
|定数の値の保証|○|△|○|
|後方互換性|○|×|△|
|プリプロセッサで使えるか|○|×|×|

#### まとめると
- 現代の一般的な開発環境であれば、基本的に`const`一択
  - メモリの使用量は微々たるものだし、よっぽど変なコーディングをしない限り定数の中身も書き換わらない
- 定数が整数であり、また定数をアドレス渡しするみたいなことがなければ`enum`も有力な選択肢
  - ただし定数を単体で定義したいのに列挙型を使うのは違和感バリバリ

```
enum emax{
  eEFFORT_VALUE_MAX = 255;
};
```

- #defineは本来は多用すべきではない
  - `#if DEBUG`のようにプリプロセッサで使いたい場合は使わざるを得ない
  - C89以前の超レガシー環境だと他に選択肢がない

### 以下、個人的に思うこと

- 保守的なメーカーだと、使用実績のある過去のコードを流用することが非常に多い
  - 今回参考にした記事でも、組み込み業界は特にその傾向があるとのこと
  
- 比較的新しめの製品でも、`#define`とかが含まれているソースは大量にある

- 新規開発したモジュールは、コーディングルールで`#define`を推奨しているわけではないので`const`とかを使うべきなのだが・・・

- 新人教育とかでその辺について知る機会がないと、実績のあるコードで使われてるからいいよね！って感じで`#define`が増殖していく

- 何が言いたいかというと、社内の勉強会って大事だよね！！


#### 参考サイト
https://stacked-tip.hateblo.jp/entry/20170205/1486265207
https://stacked-tip.hateblo.jp/entry/20170211/1486770834
http://rui.primasm.com/2013/01/c_lang_lesson_21/
http://d.hatena.ne.jp/takehikom/20140807/1407420548
